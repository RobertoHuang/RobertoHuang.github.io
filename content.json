{"meta":{"title":"黄太洪的博客","subtitle":"黄太洪的博客,大数据,物联网,云计算IAAS,云计算SAAS,云计算PAAS, Hadoop, 大数据, JavaEE, Java, 物联网, NoSQL, MongoDB, Dubbo, SpringBoot, SpringCloud, Spring, SpringMVC, Hibernate","description":"黄太洪的博客,大数据,物联网,云计算IAAS,云计算SAAS,云计算PAAS, Hadoop, 大数据, JavaEE, Java, 物联网, NoSQL, MongoDB, Dubbo, SpringBoot, SpringCloud, Spring, SpringMVC, Hibernate","author":"黄太洪","url":"http://huangth.com"},"pages":[{"title":"About","date":"2018-03-08T14:45:24.242Z","updated":"2018-03-08T14:45:24.242Z","comments":true,"path":"about/index.html","permalink":"http://huangth.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-03-08T14:45:24.245Z","updated":"2018-03-08T14:45:24.245Z","comments":true,"path":"categories/index.html","permalink":"http://huangth.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-03-08T14:45:24.246Z","updated":"2018-03-08T14:45:24.246Z","comments":true,"path":"tags/index.html","permalink":"http://huangth.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"01.Spring AOP面向切面编程详解(基于XML方式 注解方式 注入Aspectj方式)","slug":"01.Spring AOP面向切面编程详解(基于XML方式 注解方式 注入Aspectj方式)","date":"2018-03-08T04:00:00.000Z","updated":"2018-03-08T15:13:16.090Z","comments":true,"path":"2018/03/08/01.Spring AOP面向切面编程详解(基于XML方式 注解方式 注入Aspectj方式)/","link":"","permalink":"http://huangth.com/2018/03/08/01.Spring AOP面向切面编程详解(基于XML方式 注解方式 注入Aspectj方式)/","excerpt":"前言AOP即面向切面编程，是一种编程思想，OOP的延续。在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等等。在阅读本文前希望您已经对Spring有一定的了解 注:在能对代码进行添加注解方式实现AOP的话，并不推荐使用XML方式。换言之在XML方式配置更适用于不能对代码添加注解的情况下(注解配置方式推荐值&gt;XML配置方式推荐值)","text":"前言AOP即面向切面编程，是一种编程思想，OOP的延续。在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等等。在阅读本文前希望您已经对Spring有一定的了解 注:在能对代码进行添加注解方式实现AOP的话，并不推荐使用XML方式。换言之在XML方式配置更适用于不能对代码添加注解的情况下(注解配置方式推荐值&gt;XML配置方式推荐值) AOP相关术语12345678910111213141.通知(Advice):在切面的某个特定的连接点上执行的动作，即当程序到达一个执行点后会执行相对应的一段代码，也称为增强处理。通知共有如下5种类型[前置通知 后置通知 返回通知 环绕通知 抛出异常后通知]2.连接点(JoinPoint):程序执行的某个特定位置，例如类初始化前，类初始化后，方法执行前，方法执行后，方法抛出异常时等，Spring只支持方法级别的连接点，即方法执行前，方法执行后，方法抛出异常时3.切入点(Pointcut):切入点是一个筛选连接点的过程，因为在你的工程中可能有很多连接点，你只是想让其中几个，在调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法4.切面(Aspect):切面通常是指一个类，是通知和切入点的结合。到这里会发现连接点就是为了让你好理解切点产生的。通俗来说切面的配置可以理解为:什么时候在什么地方做什么事。切入点说明了在哪里干(指定到方法)，通知说明了什么时候干什么5.引入(Introduction):引入允许我们向现有的类添加新方法或属性6.织入(Weaving):把切面应用到目标对象来创建新的代理对象的过程，织入一般发生在如下几个时机: (1)编译时:当一个类文件被编译时进行织入，这需要特殊的编译器才可以做的到，例如AspectJ的织入编译器 (2)类加载时:使用特殊的ClassLoader在目标类被加载到程序之前增强类的字节代码 (3)运行时:切面在运行的某个时刻被织入,SpringAOP就是以这种方式织入切面的，原理应该是使用了JDK的动态代理技术 基于XML方式配置AOP正常通知1.编写业务类1234567public class HelloWorldBusiness &#123; public String sayHelloWorld(String language) &#123; String result = \"Hello World \" + language; System.out.println(\"真正的业务方法执行啦~~~\"); return result; &#125;&#125; 2.编写切面类1234567891011121314151617public class HelloWorldBusinessAspect &#123; public void beforeSayHelloWorld(String language) &#123; System.out.println(\"执行方法前运行，参数为:\" + language); &#125; public void afterSayHelloWorld(String language) &#123; System.out.println(\"执行方法后运行，参数为:\" + language); &#125; public void afterReturningSayHelloWorld(String language, String result) &#123; System.out.println(\"执行方法返回后运行，参数为:\" + language + \" 方法返回值为:\" + result); &#125; public void afterThrowingHelloWorld(String language, Throwable e) &#123; System.out.println(\"执行方法抛出异常后运行，参数为:\" + language + \"异常为:\" + e); &#125;&#125; 3.编写配置文件1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\"&gt; &lt;!-- 配置业务Bean --&gt; &lt;bean id=\"helloWorldBusiness\" class=\"roberto.growth.process.aop.HelloWorldBusiness\" /&gt; &lt;!-- 配置切面Bean --&gt; &lt;bean id=\"helloWorldBusinessAspect\" class=\"roberto.growth.process.aop.HelloWorldBusinessAspect\" /&gt; &lt;!-- 配置一个切面 --&gt; &lt;aop:config&gt; &lt;aop:aspect id=\"helloWorldAspect\" ref=\"helloWorldBusinessAspect\"&gt; &lt;!-- 配置一个切点 --&gt; &lt;aop:pointcut id=\"sayHelloWorldPoint\" expression=\"execution(public * roberto.growth.process.aop.HelloWorldBusiness.sayHelloWorld(..)) and args(language)\" /&gt; &lt;!-- 配置前置通知 --&gt; &lt;aop:before pointcut-ref=\"sayHelloWorldPoint\" method=\"beforeSayHelloWorld\" arg-names=\"language\"/&gt; &lt;!-- 配置前置通知 --&gt; &lt;aop:after pointcut-ref=\"sayHelloWorldPoint\" method=\"afterSayHelloWorld\" arg-names=\"language\"/&gt; &lt;!-- 配置后置返回通知 --&gt; &lt;aop:after-returning pointcut-ref=\"sayHelloWorldPoint\" method=\"afterReturningSayHelloWorld\" arg-names=\"language,result\" returning=\"result\" /&gt; &lt;!-- 异常通知 --&gt; &lt;aop:after-throwing pointcut-ref=\"sayHelloWorldPoint\" method=\"afterThrowingHelloWorld\" arg-names=\"language,e\" throwing=\"e\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4.运行HelloWorldBusiness的sayHelloWorld方法输出结果为1234执行方法前运行，参数为:JAVA真正的业务方法执行啦~~~执行方法后运行，参数为:JAVA执行方法返回后运行，参数为:JAVA 方法返回值为:Hello World JAVA 环绕通知1.编写业务类1234567public class HelloWorldBusiness &#123; public String sayHelloWorld(String language) &#123; String result = \"Hello World \" + language; System.out.println(\"真正的业务方法执行啦~~~\"); return result; &#125;&#125; 2.编写切面类123456789101112public class HelloWorldBusinessAspect &#123; public void aroundSayHelloWorld(ProceedingJoinPoint joinPoint) &#123; String language = (String) joinPoint.getArgs()[0]; try &#123; System.out.println(\"执行方法前运行，参数为:\" + language); String result = (String) joinPoint.proceed(); System.out.println(\"执行方法后运行，参数为:\" + language + \" 方法返回值为:\" + result); &#125; catch (Throwable e) &#123; System.out.println(\"执行方法抛出异常后运行，参数为:\" + language + \"异常为:\" + e); &#125; &#125;&#125; 3.编写配置文件1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\"&gt; &lt;!-- 配置业务Bean --&gt; &lt;bean id=\"helloWorldBusiness\" class=\"roberto.growth.process.aop.HelloWorldBusiness\" /&gt; &lt;!-- 配置切面Bean --&gt; &lt;bean id=\"helloWorldBusinessAspect\" class=\"roberto.growth.process.aop.HelloWorldBusinessAspect\" /&gt; &lt;!-- 配置一个切面 --&gt; &lt;aop:config&gt; &lt;aop:aspect id=\"helloWorldAspect\" ref=\"helloWorldBusinessAspect\"&gt; &lt;!-- 配置一个切点 --&gt; &lt;aop:pointcut id=\"sayHelloWorldPoint\" expression=\"execution(public * roberto.growth.process.aop.HelloWorldBusiness.sayHelloWorld(..))\" /&gt; &lt;!-- 配置环绕通知 --&gt; &lt;aop:around pointcut-ref=\"sayHelloWorldPoint\" method=\"aroundSayHelloWorld\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4.运行HelloWorldBusiness的sayHelloWorld方法输出结果为123执行方法前运行，参数为:JAVA真正的业务方法执行啦~~~执行方法后运行，参数为:JAVA 方法返回值为:Hello World JAVA 使用MethodInterceptor实现AOP1.编写业务类1234567public class HelloWorldBusiness &#123; public String sayHelloWorld(String language) &#123; String result = \"Hello World \" + language; System.out.println(\"真正的业务方法执行啦~~~\"); return result; &#125;&#125; 2.编写拦截器类 实现MethodInterceptor方法1234567891011121314public class HelloWorldBusinessAspect implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; // 获取被增强对象参数列表 String language = (String) invocation.getArguments()[0]; // 获取被增强对象的方法 Method method = invocation.getMethod(); // 继续执行业务方法 System.out.println(\"执行\" + method.getName() + \"方法前运行，参数为: \" + language); Object result = invocation.proceed(); System.out.println(\"执行方法返回后运行，参数为:\" + language + \" 方法返回值为:\" + result); return result; &#125;&#125; 3.编写配置文件123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\"&gt; &lt;!-- 配置业务Bean --&gt; &lt;bean id=\"helloWorldBusiness\" class=\"roberto.growth.process.aop.HelloWorldBusiness\" /&gt; &lt;!-- 配置切面Bean --&gt; &lt;bean id=\"helloWorldBusinessAspect\" class=\"roberto.growth.process.aop.HelloWorldBusinessAspect\" /&gt; &lt;aop:config&gt; &lt;!-- 配置一个切点 --&gt; &lt;aop:pointcut id=\"sayHelloWorldPoint\" expression=\"execution(public * roberto.growth.process.aop.HelloWorldBusiness.sayHelloWorld(..))\" /&gt; &lt;!-- 配置通知类 --&gt; &lt;aop:advisor advice-ref=\"helloWorldBusinessAspect\" pointcut-ref=\"sayHelloWorldPoint\" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4.运行HelloWorldBusiness的sayHelloWorld方法输出结果为123执行sayHelloWorld方法前运行，参数为: JAVA真正的业务方法执行啦~~~执行方法返回后运行，参数为:JAVA 方法返回值为:Hello World JAVA 注意事项1231.在Spring的配置文件中，所有的切面和通知都必须定义在&lt;aop:config&gt;元素内部。(一个application context可以包含多个&lt;aop:config&gt;)。一个&lt;aop:config&gt;可以包含pointcut，advisor和aspect元素(注意这三个元素必须按照这个顺序进行声明)2.当我们使用&lt;aop:config/&gt;方式进行配置时，可能与Spring的自动代理方式相互冲突(&lt;aop:aspectj-autoproxy/&gt;)，因此，建议要么全部使用&lt;aop:config/&gt;配置方式，要么全部使用自动代理方式，不要把两者混合使用 基于注解方式配置AOP正常通知1.编写业务类12345678@Componentpublic class HelloWorldBusiness &#123; public String sayHelloWorld(String language) &#123; String result = \"Hello World \" + language; System.out.println(\"真正的业务方法执行啦~~~\"); return result; &#125;&#125; 2.编写切面类12345678910111213141516171819202122232425262728@Aspect@Componentpublic class HelloWorldBusinessAspect &#123; @Pointcut(\"execution(public * roberto.growth.process.aop.HelloWorldBusiness.sayHelloWorld(..)) &amp;&amp; args(language)\") public void sysHelloWorldPointCut(String language) &#123; &#125; @Before(\"sysHelloWorldPointCut(language)\") public void beforeSayHelloWorld(String language) &#123; System.out.println(\"执行方法前运行，参数为:\" + language); &#125; @After(\"sysHelloWorldPointCut(language)\") public void afterSayHelloWorld(String language) &#123; System.out.println(\"执行方法后运行，参数为:\" + language); &#125; @AfterReturning(pointcut = \"sysHelloWorldPointCut(language)\", returning = \"result\") public void afterReturningSayHelloWorld(String language, String result) &#123; System.out.println(\"执行方法返回后运行，参数为:\" + language + \" 方法返回值为:\" + result); &#125; @AfterThrowing(pointcut = \"sysHelloWorldPointCut(language)\", throwing = \"e\") public void afterThrowingHelloWorld(String language, Throwable e) &#123; System.out.println(\"执行方法抛出异常后运行，参数为:\" + language + \"异常为:\" + e); &#125;&#125; 3.编写配置类(使用EnableAspectJAutoProxy注解启用自动代理功能)123456@Configuration@EnableAspectJAutoProxy@ComponentScan(basePackages = \"roberto.growth.process\")public class ApplicationConfig &#123;&#125; 4.运行HelloWorldBusiness的sayHelloWorld方法输出结果为1234执行方法前运行，参数为:JAVA真正的业务方法执行啦~~~执行方法后运行，参数为:JAVA执行方法返回后运行，参数为:JAVA 方法返回值为:Hello World JAVA 环绕通知1.编写业务类12345678@Componentpublic class HelloWorldBusiness &#123; public String sayHelloWorld(String language) &#123; String result = \"Hello World \" + language; System.out.println(\"真正的业务方法执行啦~~~\"); return result; &#125;&#125; 2.编写切面类1234567891011121314151617181920@Aspect@Componentpublic class HelloWorldBusinessAspect &#123; @Pointcut(\"execution(public * roberto.growth.process.aop.HelloWorldBusiness.sayHelloWorld(..))\") public void sysHelloWorldPointCut() &#123; &#125; @Around(\"sysHelloWorldPointCut()\") public void aroundSayHelloWorld(ProceedingJoinPoint joinPoint) &#123; String language = (String) joinPoint.getArgs()[0]; try &#123; System.out.println(\"执行方法前运行，参数为:\" + language); String result = (String) joinPoint.proceed(); System.out.println(\"执行方法后运行，参数为:\" + language + \" 方法返回值为:\" + result); &#125; catch (Throwable e) &#123; System.out.println(\"执行方法抛出异常后运行，参数为:\" + language + \"异常为:\" + e); &#125; &#125;&#125; 3.编写配置类(使用EnableAspectJAutoProxy注解启用自动代理功能)123456@Configuration@EnableAspectJAutoProxy@ComponentScan(basePackages = \"roberto.growth.process\")public class ApplicationConfig &#123;&#125; 4.运行HelloWorldBusiness的sayHelloWorld方法输出结果为123执行方法前运行，参数为:JAVA真正的业务方法执行啦~~~执行方法后运行，参数为:JAVA 方法返回值为:Hello World JAVA 纯AspectJ方式配置AOP虽然Spring AOP能够满足许多应用的切面要求，但是与AspectJ相比，Spring AOP是一个功能比较弱的AOP解决方案，AspectJ提供了Spring AOP所不能支持的许多类型的切点，例如构造器切点等 1.本地安装好AspectJ环境(具体安装自行百度) 2.在IDEA中配置AspectJ环境(具体可百度) 3.编写Aspect Demo使用AspectJ实现AOP功能 3.1.创建学生类1234567891011121314public class Student &#123; public Student() &#123; System.out.println(\"构造方法执行了\"); &#125; public void doHomeWork()&#123; System.out.println(\"学生开始做功课啦~~~\"); &#125; public static void main(String[] args) &#123; Student student = new Student(); student.doHomeWork(); &#125;&#125; 3.2.创建AspectJ切面1234567891011121314151617181920212223public aspect StudentAspect &#123; // 创建构造器切点 pointcut constructPointCut():call(roberto.growth.process.aop.Student.new()); before():constructPointCut()&#123; System.out.println(\"创建学生对象前调用\"); &#125; after():constructPointCut()&#123; System.out.println(\"创建学生对象后调用\"); &#125; // 创建学生做功课方法切点 pointcut doHomeWorkPointCut():execution(public * roberto.growth.process.aop.Student.doHomeWork(..)); before():doHomeWorkPointCut()&#123; System.out.println(\"学生做功课前\"); &#125; after():doHomeWorkPointCut()&#123; System.out.println(\"学生做功课后\"); &#125;&#125; 3.3.运行学生类的main方法，查看输出结果123456创建学生对象前调用构造方法执行了创建学生对象后调用学生做功课前学生开始做功课啦~~~学生做功课后 注意:由于AspectJ是在编译时期进行织入，所以在运行main方法前最好先手动编译一下 切入点相关切入点表达式本篇文章不介绍切入点表达式语法，与需要的读者可以参考切入点表达式可参考: 切入点表达式 切入点执行顺序123456在配置切面和通知的时候，可以指定order参数来区分切入执行先后顺序，order的值越小说明越先被执行XML方式:&lt;aop:aspect id=\"helloWorldAspect\" ref=\"helloWorldBusinessAspect\" order=\"0\"&gt;Aspect类添加注解：org.springframework.core.annotation.Order Aspect类实现接口：org.springframework.core.Ordered实现Ordered接口的getOrder()方法即可 基于注解方式引入新功能Demo:为程序员添加歌手的属性，让程序员成为斜杠青年 1.编写程序员类1234567891011public interface Programmer &#123; public void coding();&#125;@Componentpublic class ProgrammerImpl implements Programmer&#123; @Override public void coding() &#123; System.out.println(\"写最好的代码\"); &#125;&#125; 2.编写歌手类12345678910public interface Singer &#123; void sing();&#125;public class DefaultSinger implements Singer&#123; @Override public void sing() &#123; System.out.println(\"唱最动听的歌\"); &#125;&#125; 3.编写歌手引入切面 为程序员添加歌手特性123456@Aspect@Componentpublic class SingerAspect &#123; @DeclareParents(value = \"roberto.growth.process.aop.Programmer+\", defaultImpl = DefaultSinger.class) public static Singer singer;&#125; 4.编写配置类(使用EnableAspectJAutoProxy注解启用自动代理功能)123456@Configuration@EnableAspectJAutoProxy@ComponentScan(basePackages = \"roberto.growth.process\")public class ApplicationConfig &#123;&#125; 5.测试输出结果如下:(程序员即可以写代码也可以唱歌)123456789101112131415161718@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = ApplicationConfig.class)public class StudentTest &#123; @Autowired private Programmer programmer; @Test public void testSayHelloWorld() &#123; System.out.println(\"这个程序员是个歌手吗:\" + (programmer instanceof Singer)); programmer.coding(); ((Singer) programmer).sing(); &#125;&#125;控制台输出:这个程序员是个歌手吗:true写最好的代码唱最动听的歌 基于XML方式引入新功能Demo:为程序员添加歌手的属性，让程序员成为斜杠青年 1.编写程序员类12345678910public interface Programmer &#123; public void coding();&#125;public class ProgrammerImpl implements Programmer&#123; @Override public void coding() &#123; System.out.println(\"写最好的代码\"); &#125;&#125; 2.编写歌手类12345678910public interface Singer &#123; void sing();&#125;public class DefaultSinger implements Singer&#123; @Override public void sing() &#123; System.out.println(\"唱最动听的歌\"); &#125;&#125; 3.编写配置文件引入切面 为程序员添加歌手特性1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\"&gt; &lt;!-- 配置程序员类 --&gt; &lt;bean id=\"programmer\" class=\"roberto.growth.process.aop.ProgrammerImpl\" /&gt; &lt;aop:config&gt; &lt;aop:aspect&gt; &lt;aop:declare-parents types-matching=\"(roberto.growth.process.aop.Programmer+)\" implement-interface=\"roberto.growth.process.aop.Singer\" default-impl=\"roberto.growth.process.aop.DefaultSinger\" /&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4.测试输出结果如下:(程序员即可以写代码也可以唱歌)123456789101112131415161718@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class StudentTest &#123; @Autowired private Programmer programmer; @Test public void testSayHelloWorld() &#123; System.out.println(\"这个程序员是个歌手吗:\" + (programmer instanceof Singer)); programmer.coding(); ((Singer) programmer).sing(); &#125;&#125;控制台输出:这个程序员是个歌手吗:true写最好的代码唱最动听的歌","categories":[{"name":"Spring学习笔记","slug":"Spring学习笔记","permalink":"http://huangth.com/categories/Spring学习笔记/"}],"tags":[{"name":"AspectJ","slug":"AspectJ","permalink":"http://huangth.com/tags/AspectJ/"},{"name":"SpringAOP - 面向切面编程","slug":"SpringAOP-面向切面编程","permalink":"http://huangth.com/tags/SpringAOP-面向切面编程/"}]},{"title":"03.Spring IOC源码深度解析之默认标签的解析","slug":"03.Spring IOC源码深度解析之默认标签的解析","date":"2017-12-27T04:00:00.000Z","updated":"2018-03-08T14:45:24.240Z","comments":true,"path":"2017/12/27/03.Spring IOC源码深度解析之默认标签的解析/","link":"","permalink":"http://huangth.com/2017/12/27/03.Spring IOC源码深度解析之默认标签的解析/","excerpt":"标签解析在Spring的XML配置里面有两大类声明，一个是默认的如&lt;bean id=”test” class=”test.TestBean” /&gt;，另一类就是自定义的如&lt;tx:annotation-driven /&gt;，两种标签的解析方式差异是非常大的。parseBeanDefinitions方法就是用来处理使用哪种方式解析标签，判断是否默认命名空间还是自定义命名空间的办法是使用node.getNamespaceURI()获取命名空间，并与Spring中固定的命名空间http://www.springframework.org/schema/beans 进行比对，如果一致则认为是默认命名空间否则就认为是自定义命名空间解析","text":"标签解析在Spring的XML配置里面有两大类声明，一个是默认的如&lt;bean id=”test” class=”test.TestBean” /&gt;，另一类就是自定义的如&lt;tx:annotation-driven /&gt;，两种标签的解析方式差异是非常大的。parseBeanDefinitions方法就是用来处理使用哪种方式解析标签，判断是否默认命名空间还是自定义命名空间的办法是使用node.getNamespaceURI()获取命名空间，并与Spring中固定的命名空间http://www.springframework.org/schema/beans 进行比对，如果一致则认为是默认命名空间否则就认为是自定义命名空间解析 默认命名空间解析Spring将默认标签解析分为4种类型，分别为import，alias，bean，和beans标签12345678910111213141516private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; // import标签解析 importBeanDefinitionResource(ele); &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; // alias标签解析 processAliasRegistration(ele); &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; // bean标签解析 processBeanDefinition(ele, delegate); &#125; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse // beans标签解析 递归方式 doRegisterBeanDefinitions(ele); &#125;&#125; bean标签解析在4种标签中对bean标签的解析最为复杂也最为重要，所以我们从此标签开始深入分析，如果能理解此标签的解析过程，其他标签的解析自然会迎刃而解，在上一篇博客介绍了BeanDefinitionParserDelegate(bean标签解析代理对象)的创建过程，接下来我们将详细介绍使用BeanDefinitionParserDelegate对bean标签的解析过程，bean标签解析的方法的入口为processBeanDefinition12345678910111213141516protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; // 01.委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; // 02.当返回的bdHolder不为空的情况下若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // 03.解析完成后需要对解析后的bdHolder进行注册，注册操作委托给了BeanDefinitionReaderUtils的registerBeanDefinition方法 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); &#125; // 04.最后发出响应事件，通知相关监听器这个bean已经被加载 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 这个方法可以分为四个部分123401.委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析02.当返回的bdHolder不为空的情况下若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析03.解析完成后需要对解析后的bdHolder进行注册，注册操作委托给了BeanDefinitionReaderUtils的registerBeanDefinition方法04.最后发出响应事件，通知相关监听器这个bean已经被加载 parseBeanDefinitionElement(Element ele)通过该方法返回BeanDefinitionHolder类型的实例bdHolder，经过这个方法后bdHolder实例已经包含我们配置文件中配置的各种属性了，例如class, name, id, alisa等之类的属性123public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123; return parseBeanDefinitionElement(ele, null);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) &#123; // 获取Bean标签的ID属性 String id = ele.getAttribute(ID_ATTRIBUTE); // 获取Bean标签的Name属性 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); if (StringUtils.hasLength(nameAttr)) &#123; // 将name属性的值通过,; 进行分割 转为字符串数字(即在配置文件中如配置多个name 在此做处理) String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; // 如果ID为空 使用配置的第一个name属性作为ID if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isDebugEnabled()) &#123; logger.debug(\"No XML 'id' specified - using '\" + beanName + \"' as bean name and \" + aliases + \" as aliases\"); &#125; &#125; if (containingBean == null) &#123; // 校验beanName和aliases的唯一性 // 内部核心为使用usedNames集合保存所有已经使用了的beanName和alisa checkNameUniqueness(beanName, aliases, ele); &#125; // 进一步解析其他所有属性到GenericBeanDefinition对象中 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) &#123; // 如果bean没有指定beanName 那么使用默认规则为此Bean生成beanName if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123; beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Neither XML 'id' nor 'name' specified - \" + \"using generated bean name [\" + beanName + \"]\"); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); // 将信息封装到BeanDefinitionHolder对象中 return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; 该方法主要完成三个功能，第一部分是处理id，alias等标识相关的东西，第二部分是核心的标签解析，标签解析功能主要是在重载函数parseBeanDefinitionElement(ele, beanName, containingBean)方法中完成，第三部分是对beanName的处理，接下来我们重点分析第二部分内容 parseBeanDefinitionElement(Element ele, String beanName, @Nullable BeanDefinition containingBean)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); // 获取Bean标签的class属性 String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; // 获取Bean标签的parent属性 String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; try &#123; // 创建用于承载属性的AbstractBeanDefinition AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 获取bean标签各种属性 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); // 解析description标签 bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // 解析meta标签 parseMetaElements(ele, bd); // 解析lookup-method标签 parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); // 解析replaced-method标签 parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析constructor-arg标签 parseConstructorArgElements(ele, bd); // 解析property标签 parsePropertyElements(ele, bd); // 解析qualifier标签 parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error(\"Bean class [\" + className + \"] not found\", ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err); &#125; catch (Throwable ex) &#123; error(\"Unexpected failure during bean definition parsing\", ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; return null;&#125; createBeanDefinition(@Nullable String className, @Nullable String parentName) 创建用于承载属性的GenericBeanDefinition123protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName) throws ClassNotFoundException &#123; return BeanDefinitionReaderUtils.createBeanDefinition(parentName, className, this.readerContext.getBeanClassLoader());&#125; 123456789101112131415public static AbstractBeanDefinition createBeanDefinition(@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException &#123; GenericBeanDefinition bd = new GenericBeanDefinition(); // parentName可能为空 bd.setParentName(parentName); if (className != null) &#123; // 如果classLoader不为空 // 则使用传入的classLoader同一虚拟机加载类对象 否则只记录classLoader if (classLoader != null) &#123; bd.setBeanClass(ClassUtils.forName(className, classLoader)); &#125; else &#123; bd.setBeanClassName(className); &#125; &#125; return bd;&#125; parseBeanDefinitionAttributes(Element ele, String beanName, @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) 解析Bean各种属性到GenericBeanDefinition对象中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName, @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) &#123; if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123; // 如果配置了singleton属性抛出异常 该属性已经废弃 error(\"Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\", ele); &#125; else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123; // 获取Bean标签的scope属性 bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE)); &#125; else if (containingBean != null) &#123; // 如果有内部类 使用内部类的scope属性 bd.setScope(containingBean.getScope()); &#125; if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123; // 获取Bean标签的abstract属性 bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE))); &#125; // 获取Bean标签的lazy-init属性 String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE); if (DEFAULT_VALUE.equals(lazyInit)) &#123; lazyInit = this.defaults.getLazyInit(); &#125; bd.setLazyInit(TRUE_VALUE.equals(lazyInit)); // 获取Bean标签的autowire属性 String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE); bd.setAutowireMode(getAutowireMode(autowire)); // 获取Bean标签的depends-on属性 if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123; String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE); bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS)); &#125; // 获取Bean标签的autowire-candidate属性 String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE); if (\"\".equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) &#123; String candidatePattern = this.defaults.getAutowireCandidates(); if (candidatePattern != null) &#123; String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern); bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName)); &#125; &#125; else &#123; bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate)); &#125; // 获取Bean标签的primary属性 if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123; bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE))); &#125; // 获取Bean标签的init-method属性 if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123; String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE); bd.setInitMethodName(initMethodName); &#125; else if (this.defaults.getInitMethod() != null) &#123; bd.setInitMethodName(this.defaults.getInitMethod()); bd.setEnforceInitMethod(false); &#125; // 获取Bean标签的destroy-method属性 if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123; String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE); bd.setDestroyMethodName(destroyMethodName); &#125; else if (this.defaults.getDestroyMethod() != null) &#123; bd.setDestroyMethodName(this.defaults.getDestroyMethod()); bd.setEnforceDestroyMethod(false); &#125; // 获取Bean标签的factory-method属性 if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123; bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE)); &#125; // 获取Bean标签的factory-bean属性 if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123; bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE)); &#125; return bd;&#125; parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) 解析meta标签到GenericBeanDefinition中12345678910111213141516public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) &#123; // 获取当前节点下的所有子元素 NodeList nl = ele.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123; // 解析META标签 Element metaElement = (Element) node; String key = metaElement.getAttribute(KEY_ATTRIBUTE); String value = metaElement.getAttribute(VALUE_ATTRIBUTE); BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value); attribute.setSource(extractSource(metaElement)); attributeAccessor.addMetadataAttribute(attribute); &#125; &#125;&#125; parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) 解析lookup-method标签到GenericBeanDefinition中12345678910111213141516public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) &#123; // 获取当前节点下的所有子元素 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) &#123; // 解析lookup-method标签 Element ele = (Element) node; String methodName = ele.getAttribute(NAME_ATTRIBUTE); String beanRef = ele.getAttribute(BEAN_ELEMENT); LookupOverride override = new LookupOverride(methodName, beanRef); override.setSource(extractSource(ele)); overrides.addOverride(override); &#125; &#125;&#125; lookup-method通常称为获取器注入，它是一种特殊的方法注入，它是把一个方法声明为返回某种类型的bean，而实际要返回的bean是在配置文件里面配置的，可用在设计可插拔的功能上，降低程序耦合度，下面介绍一个lookup-method的demo 新建歌手方法抽象类Singer，声明抽象方法sing12345package org.springframework.roberto._05_lookup_method;public abstract class Singer &#123; protected abstract void sing();&#125; 创建歌手陈奕迅继承该抽象类，实现sing方法12345678package org.springframework.roberto._05_lookup_method;public class EasonChen extends Singer&#123; @Override public void sing() &#123; System.out.println(\"十年\"); &#125;&#125; 创建演唱会类，选择哪个歌手开演唱会123456789package org.springframework.roberto._05_lookup_method;public abstract class VocalConcert &#123; public void sing()&#123; this.getSinger().sing(); &#125; public abstract Singer getSinger();&#125; 配置文件声明如下12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;beans&gt; &lt;bean id=\"vocalConcert\" class=\"org.springframework.roberto._05_lookup_method.VocalConcert\"&gt; &lt;lookup-method name=\"getSinger\" bean=\"easonChen\" /&gt; &lt;/bean&gt; &lt;bean id=\"easonChen\" class=\"org.springframework.roberto._05_lookup_method.EasonChen\" /&gt; &lt;/beans&gt;&lt;/beans&gt; 新建测试类，测试演唱会功能1234567891011121314151617package org.springframework.roberto;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;import org.springframework.roberto._05_lookup_method.VocalConcert;@SuppressWarnings(\"all\")public class _05_LookupMethodTest &#123; @Test public void testLookupMethod() &#123; BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(\"05.lookup_method.xml\")); VocalConcert vocalConcert = (VocalConcert) beanFactory.getBean(\"vocalConcert\"); vocalConcert.sing(); &#125;&#125; 测试结果输出十年，这里只是调用了一个没有实现的抽象方法就完成了执行，其原理在于将EasonChen作为getSinger方法的返回值，这么做有利于程序的拓展。比如下次换张学友来开演唱会的时候，我们只需要把陈奕迅换成张学友即可，不用改动VocalConcert的任何代码 parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) 解析replaced-method标签到GenericBeanDefinition中12345678910111213141516171819202122232425262728public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) &#123; // 获取当前节点下的所有子元素 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) &#123; // 解析replaced-method标签 Element replacedMethodEle = (Element) node; // 提取要替换的旧方法 String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE); // 提取对应新的替换方法 String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE); ReplaceOverride replaceOverride = new ReplaceOverride(name, callback); // Look for arg-type match elements. // 记录参数 List&lt;Element&gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT); for (Element argTypeEle : argTypeEles) &#123; String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE); match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle)); if (StringUtils.hasText(match)) &#123; replaceOverride.addTypeIdentifier(match); &#125; &#125; replaceOverride.setSource(extractSource(replacedMethodEle)); overrides.addOverride(replaceOverride); &#125; &#125;&#125; replaced-method可以在运行时用新的方法替换掉旧的方法，如上面的例子假设现在举办方要陈奕迅演唱粤语版的十年(明年今日)，如果我们直接去改EasonChen中的方法其实是不合理的，我们新建一个类叫EasonChenBack实现Spring的MethodReplacer方法，并修改配置即可替换掉原来的方法12345678910111213package org.springframework.roberto._06_replace_method;import org.springframework.beans.factory.support.MethodReplacer;import java.lang.reflect.Method;public class EasonChenBack implements MethodReplacer&#123; @Override public Object reimplement(Object obj, Method method, Object[] args) throws Throwable &#123; System.out.println(\"明年今日\"); return null; &#125;&#125; 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;beans&gt; &lt;bean id=\"vocalConcert\" class=\"org.springframework.roberto._05_lookup_method.VocalConcert\"&gt; &lt;lookup-method name=\"getSinger\" bean=\"easonChen\" /&gt; &lt;/bean&gt; &lt;bean id=\"easonChen\" class=\"org.springframework.roberto._05_lookup_method.EasonChen\"&gt; &lt;replaced-method name=\"sing\" replacer=\"easonChenBack\" /&gt; &lt;/bean&gt; &lt;bean id=\"easonChenBack\" class=\"org.springframework.roberto._06_replace_method.EasonChenBack\"/&gt; &lt;/beans&gt;&lt;/beans&gt; 运行结果输出十年今日，也就是原来EasonChen中的sing方法已经被替换掉了 parseConstructorArgElements(Element beanEle, BeanDefinition bd) 解析constructor-arg标签到GenericBeanDefinition中1234567891011public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) &#123; // 获取当前节点下的所有子元素 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) &#123; // 解析constructor-arg标签 parseConstructorArgElement((Element) node, bd); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public void parseConstructorArgElement(Element ele, BeanDefinition bd) &#123; // 获取index属性 String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE); // 获取type属性 String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE); // 获取name属性 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); if (StringUtils.hasLength(indexAttr)) &#123; try &#123; int index = Integer.parseInt(indexAttr); if (index &lt; 0) &#123; error(\"'index' cannot be lower than 0\", ele); &#125; else &#123; try &#123; this.parseState.push(new ConstructorArgumentEntry(index)); // 解析ele对应的属性元素 Object value = parsePropertyValue(ele, bd, null); ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value); if (StringUtils.hasLength(typeAttr)) &#123; valueHolder.setType(typeAttr); &#125; if (StringUtils.hasLength(nameAttr)) &#123; valueHolder.setName(nameAttr); &#125; valueHolder.setSource(extractSource(ele)); // 不允许重复指定相同的参数 if (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) &#123; error(\"Ambiguous constructor-arg entries for index \" + index, ele); &#125; else &#123; bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder); &#125; &#125; finally &#123; this.parseState.pop(); &#125; &#125; &#125; catch (NumberFormatException ex) &#123; error(\"Attribute 'index' of tag 'constructor-arg' must be an integer\", ele); &#125; &#125; else &#123; try &#123; // 没有index属性解析 this.parseState.push(new ConstructorArgumentEntry()); // 解析ele对应的属性元素 Object value = parsePropertyValue(ele, bd, null); ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value); if (StringUtils.hasLength(typeAttr)) &#123; valueHolder.setType(typeAttr); &#125; if (StringUtils.hasLength(nameAttr)) &#123; valueHolder.setName(nameAttr); &#125; valueHolder.setSource(extractSource(ele)); bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder); &#125; finally &#123; this.parseState.pop(); &#125; &#125;&#125; parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) 该方法用于获取一个属性元素的值，可以是ref value或者list等，如果propertyName设置为null即为构造函数获取值方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) &#123; String elementName = (propertyName != null) ? \"&lt;property&gt; element for property '\" + propertyName + \"'\" : \"&lt;constructor-arg&gt; element\"; // 一个属性只能对应一种子标签 ref value或者list等 NodeList nl = ele.getChildNodes(); Element subElement = null; for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); // 对description或者meta不处理 if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp; !nodeNameEquals(node, META_ELEMENT)) &#123; // Child element is what we're looking for. if (subElement != null) &#123; error(elementName + \" must not contain more than one sub-element\", ele); &#125; else &#123; subElement = (Element) node; &#125; &#125; &#125; // 获取ref属性 boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE); // 获取value属性 boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE); // 1.同时既有ref属性又有value属性 则报错 // 2.存在ref属性或者value属性且又有子元素 则报错 if ((hasRefAttribute &amp;&amp; hasValueAttribute) || ((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) &#123; error(elementName + \" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element\", ele); &#125; if (hasRefAttribute) &#123; // 对ref属性处理 String refName = ele.getAttribute(REF_ATTRIBUTE); if (!StringUtils.hasText(refName)) &#123; error(elementName + \" contains empty 'ref' attribute\", ele); &#125; RuntimeBeanReference ref = new RuntimeBeanReference(refName); ref.setSource(extractSource(ele)); return ref; &#125; else if (hasValueAttribute) &#123; // 对value属性处理 TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE)); valueHolder.setSource(extractSource(ele)); return valueHolder; &#125; else if (subElement != null) &#123; // 子元素解析 return parsePropertySubElement(subElement, bd); &#125; else &#123; // 既没有ref也没有value也没有子元素 报错 error(elementName + \" must specify a ref or value\", ele); return null; &#125;&#125; 这里主要流程可以分为五个部分123451.解析出子元素ref，value，list，map等2.校验是否同时拥有ref属性和value属性 或存在ref属性或者value属性但是又有子元素3.解析ref属性用RuntimeBeanReference封装4.解析value属性用TypedStringValue封装5.使用parsePropertySubElement对子元素进行处理 子元素标签解析123public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) &#123; return parsePropertySubElement(ele, bd, null);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) &#123; // 判断是否使用默认命名空间 if (!isDefaultNamespace(ele)) &#123; // 自定义标签解析 return parseNestedCustomElement(ele, bd); &#125; else if (nodeNameEquals(ele, BEAN_ELEMENT)) &#123; // bean标签解析 BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd); if (nestedBd != null) &#123; nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd); &#125; return nestedBd; &#125; else if (nodeNameEquals(ele, REF_ELEMENT)) &#123; // ref标签解析 // 获取ref标签bean属性 String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE); boolean toParent = false; if (!StringUtils.hasLength(refName)) &#123; // 解析ref标签parent属性 refName = ele.getAttribute(PARENT_REF_ATTRIBUTE); toParent = true; if (!StringUtils.hasLength(refName)) &#123; error(\"'bean' or 'parent' is required for &lt;ref&gt; element\", ele); return null; &#125; &#125; if (!StringUtils.hasText(refName)) &#123; error(\"&lt;ref&gt; element contains empty target attribute\", ele); return null; &#125; RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent); ref.setSource(extractSource(ele)); return ref; &#125; else if (nodeNameEquals(ele, IDREF_ELEMENT)) &#123; // idref标签解析 return parseIdRefElement(ele); &#125; else if (nodeNameEquals(ele, VALUE_ELEMENT)) &#123; // value标签解析 return parseValueElement(ele, defaultValueType); &#125; else if (nodeNameEquals(ele, NULL_ELEMENT)) &#123; // null标签解析 TypedStringValue nullHolder = new TypedStringValue(null); nullHolder.setSource(extractSource(ele)); return nullHolder; &#125; else if (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123; // array标签解析 return parseArrayElement(ele, bd); &#125; else if (nodeNameEquals(ele, LIST_ELEMENT)) &#123; // list标签解析 return parseListElement(ele, bd); &#125; else if (nodeNameEquals(ele, SET_ELEMENT)) &#123; // set标签解析 return parseSetElement(ele, bd); &#125; else if (nodeNameEquals(ele, MAP_ELEMENT)) &#123; // map标签解析 return parseMapElement(ele, bd); &#125; else if (nodeNameEquals(ele, PROPS_ELEMENT)) &#123; // props标签解析 return parsePropsElement(ele); &#125; else &#123; error(\"Unknown property sub-element: [\" + ele.getNodeName() + \"]\", ele); return null; &#125;&#125; 对property各种子元素处理逻辑请自行分析，不再详述 parsePropertyElements(Element beanEle, BeanDefinition bd) 解析property标签到GenericBeanDefinition中1234567891011public void parsePropertyElements(Element beanEle, BeanDefinition bd) &#123; // 获取当前节点下的所有子元素 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123; // 解析property标签 parsePropertyElement((Element) node, bd); &#125; &#125;&#125; 12345678910111213141516171819202122232425public void parsePropertyElement(Element ele, BeanDefinition bd) &#123; // 获取name属性 String propertyName = ele.getAttribute(NAME_ATTRIBUTE); if (!StringUtils.hasLength(propertyName)) &#123; error(\"Tag 'property' must have a 'name' attribute\", ele); return; &#125; this.parseState.push(new PropertyEntry(propertyName)); try &#123; // 不允许多次对同一属性配置 if (bd.getPropertyValues().contains(propertyName)) &#123; error(\"Multiple 'property' definitions for property '\" + propertyName + \"'\", ele); return; &#125; // 获取属性元素的值 Object val = parsePropertyValue(ele, bd, propertyName); PropertyValue pv = new PropertyValue(propertyName, val); // 解析meta标签 parseMetaElements(ele, pv); pv.setSource(extractSource(ele)); bd.getPropertyValues().addPropertyValue(pv); &#125; finally &#123; this.parseState.pop(); &#125;&#125; parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) 解析qualifier标签到GenericBeanDefinition中1234567891011public void parseQualifierElements(Element beanEle, AbstractBeanDefinition bd) &#123; // 获取当前节点下的所有子元素 NodeList nl = beanEle.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ELEMENT)) &#123; // 解析qualifier标签 parseQualifierElement((Element) node, bd); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839public void parseQualifierElement(Element ele, AbstractBeanDefinition bd) &#123; // 获取type属性 String typeName = ele.getAttribute(TYPE_ATTRIBUTE); if (!StringUtils.hasLength(typeName)) &#123; error(\"Tag 'qualifier' must have a 'type' attribute\", ele); return; &#125; this.parseState.push(new QualifierEntry(typeName)); try &#123; AutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName); qualifier.setSource(extractSource(ele)); // 获取value属性 String value = ele.getAttribute(VALUE_ATTRIBUTE); if (StringUtils.hasLength(value)) &#123; qualifier.setAttribute(AutowireCandidateQualifier.VALUE_KEY, value); &#125; NodeList nl = ele.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, QUALIFIER_ATTRIBUTE_ELEMENT)) &#123; // 解析attribute标签 Element attributeEle = (Element) node; String attributeName = attributeEle.getAttribute(KEY_ATTRIBUTE); String attributeValue = attributeEle.getAttribute(VALUE_ATTRIBUTE); if (StringUtils.hasLength(attributeName) &amp;&amp; StringUtils.hasLength(attributeValue)) &#123; BeanMetadataAttribute attribute = new BeanMetadataAttribute(attributeName, attributeValue); attribute.setSource(extractSource(attributeEle)); qualifier.addMetadataAttribute(attribute); &#125; else &#123; error(\"Qualifier 'attribute' tag must have a 'name' and 'value'\", attributeEle); return; &#125; &#125; &#125; bd.addQualifier(qualifier); &#125; finally &#123; this.parseState.pop(); &#125;&#125; decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder definitionHolder)当返回的bdHolder不为空的情况下若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析，这里有别于自定义类型的解析123public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder definitionHolder) &#123; return decorateBeanDefinitionIfRequired(ele, definitionHolder, null);&#125; 1234567891011121314151617181920public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder definitionHolder, @Nullable BeanDefinition containingBd) &#123; BeanDefinitionHolder finalDefinition = definitionHolder; // 遍历所有属性 查看是否有适用于修饰的属性 NamedNodeMap attributes = ele.getAttributes(); for (int i = 0; i &lt; attributes.getLength(); i++) &#123; Node node = attributes.item(i); finalDefinition = decorateIfRequired(node, finalDefinition, containingBd); &#125; // 遍历所有的子节点 判断是否有适用于修饰的子元素 NodeList children = ele.getChildNodes(); for (int i = 0; i &lt; children.getLength(); i++) &#123; Node node = children.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) &#123; finalDefinition = decorateIfRequired(node, finalDefinition, containingBd); &#125; &#125; return finalDefinition;&#125; 1234567891011121314151617181920212223public BeanDefinitionHolder decorateIfRequired(Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) &#123; // 获取自定义标签的命名空间 String namespaceUri = getNamespaceURI(node); // 对于非默认标签进行装饰 if (namespaceUri != null &amp;&amp; !isDefaultNamespace(namespaceUri)) &#123; // 根据命名空间找到对应的处理器 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler != null) &#123; // 进行修饰 BeanDefinitionHolder decorated = handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd)); if (decorated != null) &#123; return decorated; &#125; &#125; else if (namespaceUri.startsWith(\"http://www.springframework.org/\")) &#123; error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", node); &#125; else &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"No Spring NamespaceHandler found for XML schema namespace [\" + namespaceUri + \"]\"); &#125; &#125; &#125; return originalDef;&#125; registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)在解析完配置文件后我们已经获取了bean的所有属性，接下来就是对bean的注册了12345678910111213public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException &#123; // 使用beanName做唯一标识符 String beanName = definitionHolder.getBeanName(); // 注册bean的核心代码 registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // 为bean注册所有的别名 String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String alias : aliases) &#123; registry.registerAlias(beanName, alias); &#125; &#125;&#125; 以上代码主要完成两个功能，一是使用beanName注册beanDefinition，二是完成了对别名的注册 使用beanName注册beanDefinition1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; Assert.hasText(beanName, \"Bean name must not be empty\"); Assert.notNull(beanDefinition, \"BeanDefinition must not be null\"); if (beanDefinition instanceof AbstractBeanDefinition) &#123; try &#123; // 注册前的最后一次校验，这里的校验不同于XML文件校验 // 主要是对于AbstractBeanDefinition属性中的methodOverrides校验 // 校验methodOverrides是否与工厂方法并存或者methodOverrides对于的方法根本不存在 ((AbstractBeanDefinition) beanDefinition).validate(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \"Validation of bean definition failed\", ex); &#125; &#125; BeanDefinition oldBeanDefinition; // 获取缓存中的beanDefinition oldBeanDefinition = this.beanDefinitionMap.get(beanName); if (oldBeanDefinition != null) &#123; // 如果缓存中存在 判断是否允许覆盖 if (!isAllowBeanDefinitionOverriding()) &#123; throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \"Cannot register bean definition [\" + beanDefinition + \"] for bean '\" + beanName + \"': There is already [\" + oldBeanDefinition + \"] bound.\"); &#125; else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123; if (this.logger.isWarnEnabled()) &#123; this.logger.warn(\"Overriding user-defined bean definition for bean '\" + beanName + \"' with a framework-generated bean definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); &#125; &#125; else if (!beanDefinition.equals(oldBeanDefinition)) &#123; if (this.logger.isInfoEnabled()) &#123; this.logger.info(\"Overriding bean definition for bean '\" + beanName + \"' with a different definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); &#125; &#125; else &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Overriding bean definition for bean '\" + beanName + \"' with an equivalent definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); &#125; &#125; // 如果允许覆盖，保存beanDefinition到beanDefinitionMap中 this.beanDefinitionMap.put(beanName, beanDefinition); &#125; else &#123; // 判断是否已经开始创建bean if (hasBeanCreationStarted()) &#123; synchronized (this.beanDefinitionMap) &#123; // 保存beanDefinition到beanDefinitionMap中 this.beanDefinitionMap.put(beanName, beanDefinition); // 更新已经注册的beanName List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; if (this.manualSingletonNames.contains(beanName)) &#123; Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; &#125; &#125; &#125; else &#123; // 还没开始创建bean this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName); this.manualSingletonNames.remove(beanName); &#125; this.frozenBeanDefinitionNames = null; &#125; if (oldBeanDefinition != null || containsSingleton(beanName)) &#123; // 重置beanName对应的缓存 resetBeanDefinition(beanName); &#125;&#125; 使用beanName注册beanDefinition主要完成了以下几个功能12341.对AbstractBeanDefinition的校验，主要是针对AbstractBeanDefinition的methodOverrides属性的2.对beanName已经注册的情况的处理，如果设置了不允许bean的覆盖，则需要抛出异常，否则直接覆盖3.使用beanName作为key，beanDefinition为Value加入beanDefinitionMap存储4.如果缓存中已经存在，并且该bean为单例模式则清楚beanName对应的缓存 注册别名1234567891011121314151617181920212223public void registerAlias(String name, String alias) &#123; Assert.hasText(name, \"'name' must not be empty\"); Assert.hasText(alias, \"'alias' must not be empty\"); if (alias.equals(name)) &#123; // 如果beanName与alias相同的话不记录alias 并删除对应的alias this.aliasMap.remove(alias); &#125; else &#123; String registeredName = this.aliasMap.get(alias); if (registeredName != null) &#123; if (registeredName.equals(name)) &#123; // 如果别名已经注册过并且指向的name和当前name相同 不做任何处理 return; &#125; // 如果alias不允许被覆盖则抛出异常 if (!allowAliasOverriding()) &#123; throw new IllegalStateException(\"Cannot register alias '\" + alias + \"' for name '\" + name + \"': It is already registered for name '\" + registeredName + \"'.\"); &#125; &#125; // 校验循环指向依赖 如A-&gt;B B-&gt;C C-&gt;A则出错 checkForAliasCircle(name, alias); this.aliasMap.put(alias, name); &#125;&#125; 注册别名主要完成了以下工作12341.如果beanName与alias相同的话不记录alias 并删除对应的alias2.如果别名已经注册过并且指向的name和当前name相同 不做任何处理3.如果别名已经注册过并且指向的name和当前name不相同 判断是否允许被覆盖4.校验循环指向依赖 如A-&gt;B B-&gt;C C-&gt;A则出错 fireComponentRegistered(ComponentDefinition componentDefinition)通过fireComponentRegistered方法进行通知监听器解析及注册完成工作，这里的实现只为扩展，当程序开发人员需要对注册BeanDefinition事件进行监听时，可以通过注册监听器的方式并将处理逻辑写入监听器中，目前Spring中并没有对此事件做任何处理 alias标签解析Spring提供了&lt;alias name=”testBean” alias=”testBeanAlias” /&gt;方式来进行别名的配置，该标签解析是在processAliasRegistration(Element ele)方法中完成的12345678910111213141516171819202122232425protected void processAliasRegistration(Element ele) &#123; // 获取alisa标签name属性 String name = ele.getAttribute(NAME_ATTRIBUTE); // 获取alisa标签alias属性 String alias = ele.getAttribute(ALIAS_ATTRIBUTE); boolean valid = true; if (!StringUtils.hasText(name)) &#123; getReaderContext().error(\"Name must not be empty\", ele); valid = false; &#125; if (!StringUtils.hasText(alias)) &#123; getReaderContext().error(\"Alias must not be empty\", ele); valid = false; &#125; if (valid) &#123; try &#123; // 进行别名注册 getReaderContext().getRegistry().registerAlias(name, alias); &#125; catch (Exception ex) &#123; getReaderContext().error(\"Failed to register alias '\" + alias + \"' for bean with name '\" + name + \"'\", ele, ex); &#125; // 别名注册后告知监听器做相应处理 getReaderContext().fireAliasRegistered(name, alias, extractSource(ele)); &#125;&#125; 该方法首先对alias标签属性进行提取校验，校验通过后进行别名注册，别名注册和bean标签解析中的别名注册一直，此处不再赘述 import标签解析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void importBeanDefinitionResource(Element ele) &#123; // 获取import标签的resource属性 String location = ele.getAttribute(RESOURCE_ATTRIBUTE); // 如果不存在则不做任何处理 if (!StringUtils.hasText(location)) &#123; getReaderContext().error(\"Resource location must not be empty\", ele); return; &#125; // 解析占位符属性 格式如\"$&#123;user.dir&#125;\" location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location); Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;&gt;(4); // 判断资源是绝对路径还是相对路径 boolean absoluteLocation = false; try &#123; absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute(); &#125; catch (URISyntaxException ex) &#123; // cannot convert to an URI, considering the location relative // unless it is the well-known Spring prefix \"classpath*:\" &#125; // 如果是绝对路径则直接根据地址加载对应的配置文件 if (absoluteLocation) &#123; try &#123; int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources); if (logger.isDebugEnabled()) &#123; logger.debug(\"Imported \" + importCount + \" bean definitions from URL location [\" + location + \"]\"); &#125; &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(\"Failed to import bean definitions from URL location [\" + location + \"]\", ele, ex); &#125; &#125; else &#123; try &#123; int importCount; // 根据相对路径加载资源 Resource relativeResource = getReaderContext().getResource().createRelative(location); if (relativeResource.exists()) &#123; importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource); actualResources.add(relativeResource); &#125; else &#123; String baseLocation = getReaderContext().getResource().getURL().toString(); importCount = getReaderContext().getReader().loadBeanDefinitions(StringUtils.applyRelativePath(baseLocation, location), actualResources); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Imported \" + importCount + \" bean definitions from relative location [\" + location + \"]\"); &#125; &#125; catch (IOException ex) &#123; getReaderContext().error(\"Failed to resolve current resource location\", ele, ex); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(\"Failed to import bean definitions from relative location [\" + location + \"]\", ele, ex); &#125; &#125; // 解析后进行监听器激活处理 Resource[] actResArray = actualResources.toArray(new Resource[actualResources.size()]); getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));&#125; 以上代码完成了对import标签的处理，大致步骤如下1234561.获取resource属性所表示的路径2.解析路径中的属性占位符 如\"$&#123;user.dir&#125;\"3.判定location是绝对路径还是相对路径4.如果是绝对路径则递归调用bean的解析过程，进行另一次解析5.如果是相对路径则计算出绝对路径并进行解析6.通知监听器，解析完成 beans标签解析嵌入式beans标签与单独配置文件并没有太大差别，其原理是递归调用了beans的解析过程","categories":[{"name":"Spring源码深度解析","slug":"Spring源码深度解析","permalink":"http://huangth.com/categories/Spring源码深度解析/"}],"tags":[{"name":"Spring源码深度解析","slug":"Spring源码深度解析","permalink":"http://huangth.com/tags/Spring源码深度解析/"},{"name":"Spring IOC源码解析","slug":"Spring-IOC源码解析","permalink":"http://huangth.com/tags/Spring-IOC源码解析/"},{"name":"Spring默认标签解析","slug":"Spring默认标签解析","permalink":"http://huangth.com/tags/Spring默认标签解析/"}]},{"title":"02.Spring IOC源码深度解析之容器的基本实现","slug":"02.Spring IOC源码深度解析之容器的基本实现","date":"2017-12-23T04:00:00.000Z","updated":"2018-03-08T14:45:24.238Z","comments":true,"path":"2017/12/23/02.Spring IOC源码深度解析之容器的基本实现/","link":"","permalink":"http://huangth.com/2017/12/23/02.Spring IOC源码深度解析之容器的基本实现/","excerpt":"在搭建完Spring源码阅读环境后，大家比较困惑的应该就是从哪里开始入手阅读Spring源码了，众所周知Spring的两大特性为IOC和AOP，那我们先以IOC为例跟进Spring源码。IOC(Inversion of Control):即”控制反转”，它不是什么技术而是一种设计思想，在传统的JAVA程序设计中当我们需要创建一个对象时，我们直接在对象内部通过new进行创建，而IOC是有一个专门的容器来控制对象的创建(即将对象的创建过程交由容器来完成) ，IOC也叫DI(Dependency Injection):DI即依赖注入，由容器动态的将某个依赖关系注入到组件之中，理解DI的关键是:谁依赖谁 为什么需要依赖 谁注入谁 注入了什么","text":"在搭建完Spring源码阅读环境后，大家比较困惑的应该就是从哪里开始入手阅读Spring源码了，众所周知Spring的两大特性为IOC和AOP，那我们先以IOC为例跟进Spring源码。IOC(Inversion of Control):即”控制反转”，它不是什么技术而是一种设计思想，在传统的JAVA程序设计中当我们需要创建一个对象时，我们直接在对象内部通过new进行创建，而IOC是有一个专门的容器来控制对象的创建(即将对象的创建过程交由容器来完成) ，IOC也叫DI(Dependency Injection):DI即依赖注入，由容器动态的将某个依赖关系注入到组件之中，理解DI的关键是:谁依赖谁 为什么需要依赖 谁注入谁 注入了什么 容器基本用法为了更好的理解Spring源码，后续我们会创建许多的测试案例。为了保证逻辑清晰我选择的是在spring-framework项目下新建一个独立的模块spring-roberto，该模块通过引用其他子模块来完成功能测试。在spring-framework下新增子模块spring-roberto，并修改gradle配置内容如下(添加了spring-beans的依赖)123456789101112131415group 'org.springframework'version '5.0.3.BUILD-SNAPSHOT'apply plugin: 'java'sourceCompatibility = 1.8repositories &#123; mavenCentral()&#125;dependencies &#123; compile(project(\":spring-beans\")) testCompile group: 'junit', name: 'junit', version: '4.12'&#125; Spring IOC的简单实现新建实体类TestBean.java12345678910111213package _01.ioc_simple_impl;public class TestBean &#123; private String str = \"testStr\"; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; this.str = str; &#125;&#125; 新建applicationContext.xml文件1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"testBean\" class=\"org.springframework.roberto._01_iocsimpleimpl.TestBean\" /&gt;&lt;/beans&gt; 新建测试类1234567891011121314151617package org.springframework.roberto;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;import org.springframework.roberto._01_iocsimpleimpl.TestBean;@SuppressWarnings(\"deprecation\")public class _01_IocSimpleImplTest &#123; @Test public void testSimpleLoad() &#123; BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(\"01.ioc_simple_impl.xml\")); TestBean testBean = (TestBean) beanFactory.getBean(\"testBean\"); System.out.println(testBean.getStr()); &#125;&#125; 运行结果输出testStr，到此我们已经实现了IOC的功能。这个过程非常的简单但是内部实现原理却是九曲十八弯，相信你在看完后续的源码解析时，你也会对封装有一个更好的理解(特别是等研究源码半个月或者一个月发现其实你只跟进阅读2行代码时) 容器基本功能分析以上测试代码主要帮我们完成如下几个功能:1231.读取applicationContext.xml文件2.根据applicationContext.xml中的配置找到对应类的配置并实例化3.调用实例化后的实例，返回结果 资源文件加载资源文件加载的代码为:1BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\")); 时序图: 通过时序图可以很清楚的看出资源加载过程是:121.将配置文件读取成Resource资源文件的实例对象2.使用Resource资源文件对XmlBeanFactory进行初始化操作 加载配置文件new ClassPathResource(“applicationContext.xml”)过程分析123public ClassPathResource(String path) &#123; this(path, (ClassLoader) null);&#125; 1234567891011public ClassPathResource(String path, @Nullable ClassLoader classLoader) &#123; Assert.notNull(path, \"Path must not be null\"); // 对配置文件路径进行处理 String pathToUse = StringUtils.cleanPath(path); if (pathToUse.startsWith(\"/\")) &#123; pathToUse = pathToUse.substring(1); &#125; // 初始化path和classLoader this.path = pathToUse; this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());&#125; Spring配置文件的加载使用ClassPathResource，打开ClassPathResource类继承结构发现它实现了Resource接口 Resource接口抽象了所有Spring内部使用到的底层资源:File、URL、Classpath等，并且Resource接口提供了几个重要的方法如:存在性(exists)、可读性(isReadable)、是否处于打开状态(isOpen) 。对不同来源的资源文件Spring都内置了不同的Resource实现，如:文件(FileSystemResource)、Classpath资源(ClassPathResource)、URL资源(UrlResource)、InputStream资源(InputStreamResource)、Byte数组(ByteArrayResource)等 同时Resource继承了InputStreamSource接口，InputStreamSource封装任何能返回InputStream的类，它只有一个方法定义getInputStream()，该方法返回一个InputStream对象。在日常开发工作中资源文件加载也是经常用到的，可以直接使用Spring提供的类，比如在加载文件时可以使用如下代码:12Resource resource = new ClassPathResource(\"applicationContext.xml\");InputStream inputStream = resource.getInputStream(); 初始化XmlBeanFactorynew XmlBeanFactory(resource)过程分析123public XmlBeanFactory(Resource resource) throws BeansException &#123; this(resource, null);&#125; 1234567public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException &#123; // ignoreDependencyInterface(BeanNameAware.class); // ignoreDependencyInterface(BeanFactoryAware.class); // ignoreDependencyInterface(BeanClassLoaderAware.class); super(parentBeanFactory); this.reader.loadBeanDefinitions(resource);&#125; 在super(parentBeanFactory)方法中调用了ignoreDependencyInterface(Class&lt;?&gt; ifc)方法，以下是郝佳Spring源码深度解析中对ignoreDependencyInterface(Class&lt;?&gt;&gt; ifc)的解释123举例来说当A中有属性B，那么当Spring在获取A的Bean的时候如果其属性B还没有初始化，那么Spring会自动初始化B，这也是Spring中提供的一个重要特性但是某些情况下B不会被初始化，其中的一种情况就是B实现了BeanNameAware接口。Spring中是这样介绍的:自动装配时忽略给定的依赖接口，典型应用是通过其他方式解析Application上下文注册依赖，类似于BeanFactory通过BeanFactoryAware进行注入或者ApplicationContext通过ApplicationContextAware进行注入 经过尝试发现即使属性B实现了以上接口还是会被初始化，经过查看源码个人认为以上的理解并不正确。我认为此处说的忽略自动注入是指:假设A实现了BeanFactoryAware接口重写了setBeanFactory方法，那么属性beanFactory是不能通过自动注入方式进行注入 源码分析过程:ignoreDependencyInterface(Class&lt;?&gt; ifc)方法实现的功能其实是往ignoredDependencyInterfaces中添加Class，而通过Find Usage查找调用链发现使用ignoredDependencyInterfaces属性进行判断的方法为AbstractAutowireCapableBeanFactory中的isExcludedFromDependencyCheck，继续搜索调用链找到AbstractAutowireCapableBeanFactory中的unsatisfiedNonSimpleProperties，而unsatisfiedNonSimpleProperties是在AbstractAutowireCapableBeanFactory中的autowireByName和autowireByType中调用的。即在autowireByName和autowireByType方法中如果发现类继承了对应的以上三个接口，那么对应的属性是会被忽略注入的 注:在Spring不是所有类型都能自动装配，Object，基本数据类型及(Date CharSequence Number URI URL Class)等是不会被自动装配的，此处的自动装配指配置文件中的autowire而非注解@Autowired 加载Bean的主要逻辑是在this.reader.loadBeanDefinitions(resource);中执行的，下面为该方法的时序图123456789101112131415161718192021222324252627282930313233343536public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, \"EncodedResource must not be null\"); if (logger.isInfoEnabled()) &#123; logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource()); &#125; Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; // 配置文件循环引入检查(在配置文件中import自己即可进入该异常) if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException(\"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\"); &#125; try &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // 加载Bean return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(\"IOException parsing XML document from \" + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 该方法可拆分为数据准备和核心处理两个部分，核心部分代码为doLoadBeanDefinitions(inputSource, encodedResource.getResource());123456789101112131415161718protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; Document doc = doLoadDocument(inputSource, resource); return registerBeanDefinitions(doc, resource); &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (SAXParseException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), \"Line \" + ex.getLineNumber() + \" in XML document from \" + resource + \" is invalid\", ex); &#125; catch (SAXException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), \"XML document from \" + resource + \" is invalid\", ex); &#125; catch (ParserConfigurationException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), \"Parser configuration exception parsing XML from \" + resource, ex); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), \"IOException parsing XML document from \" + resource, ex); &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), \"Unexpected exception parsing XML document from \" + resource, ex); &#125;&#125; 以上为Bean加载核心处理部分代码，总共处理了两件事，一是解析配置的XML文件转为Document对象，二是根据解析出来的Document注册Bean信息 解析配置文件为Document对象12345protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123; // getEntityResolver()获取EntityResolver对象 // getValidationModeForResource(resource) 获取资源校验模式 return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware());&#125; 在执行loadDocument操作前做了两个准备工作，第一是获取EntiryResolver对象，第二是获取XML校验模式，最后根据这些参数解析XML配置文件转换为Document 官网对于EntityResolver的解释为:如果SAX应用程序需要实现自定义处理外部实体，则必须实现此接口。解析一个XML文件，SAX首先读取该XML文档上的说明，根据声明去寻找对应的DTD定义，以便对文档进行一个验证。默认是通过网络下载对应的声明的，但是该过程容易因为网络问题等原因导致出错，EntityResolver的作用是项目本身就可以提供一个如何寻找DTD声明的方法(org.springframework.beans.factory.xml.ResourceEntityResolver#resolveEntity(String publicId, String systemId)),即由程序来实现寻找DTD声明的过程(该部分代码不影响理解Spring主流程了解即可) getValidationModeForResource(resource)获取XML校验模式123456789101112131415protected int getValidationModeForResource(Resource resource) &#123; // 判断是否手动设置了校验模式 int validationModeToUse = getValidationMode(); if (validationModeToUse != VALIDATION_AUTO) &#123; return validationModeToUse; &#125; // 判断配置文件中是否有DOCTYPE字段 区分是DTD还是XSD int detectedMode = detectValidationMode(resource); if (detectedMode != VALIDATION_AUTO) &#123; return detectedMode; &#125; // 默认为XSD方式解析 return VALIDATION_XSD;&#125; loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware)12345678public Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123; DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); if (logger.isDebugEnabled()) &#123; logger.debug(\"Using JAXP provider [\" + factory.getClass().getName() + \"]\"); &#125; DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); return builder.parse(inputSource);&#125; 这部分代码没啥好说的，就是使用最原始的javax.xml.parsers解析配置的XML文件转为Document过程，至此我们已经将配置文件XML=&gt;Document对象了 解析及注册BeanDefinitions对象12345678910public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; // 新建BeanDefinitionDocumentReader实例对象(DefaultBeanDefinitionDocumentReader) BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 记录统计前BeanDefinition加载个数 int countBefore = getRegistry().getBeanDefinitionCount(); // 加载注册Bean documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); // 记录本次加载的BeanDefinition个数 return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 加载注册Bean执行过程:123456public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root);&#125; 经过艰难险阻磕磕碰碰，终于接触到了核心逻辑的底部doRegisterBeanDefinitions(root);如果说之前一直是XML加载解析准备阶段，那么doRegisterBeanDefinitions(root);算是真正的开始解析了 123456789101112131415161718192021222324252627282930protected void doRegisterBeanDefinitions(Element root) &#123; BeanDefinitionParserDelegate parent = this.delegate; // 创建Bean解析代理对象 实际上正在的解析过程是在BeanDefinitionParserDelegate这个代理中 this.delegate = createDelegate(getReaderContext(), root, parent); // 处理Profile属性 if (this.delegate.isDefaultNamespace(root)) &#123; String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + getReaderContext().getResource()); &#125; return; &#125; &#125; &#125; // 解析前操作 为了扩展交给子类实现 preProcessXml(root); // 解析过程 parseBeanDefinitions(root, this.delegate); // 解析后操作 为了扩展交给子类实现 postProcessXml(root); this.delegate = parent;&#125; doRegisterBeanDefinitions(Element root)主要完成了三个功能1231.创建Bean解析代理对象2.对Profile属性进行处理3.对标签进行解析(在下一篇博客介绍) 创建Bean解析代理对象过程解析:1234567protected BeanDefinitionParserDelegate createDelegate(XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) &#123; // 新建BeanDefinitionParserDelegate对象 BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext); // 参数初始化 delegate.initDefaults(root, parentDelegate); return delegate;&#125; 先是调用构造函数新建BeanDefinitionParserDelegate实例，然后调用initDefaults(root, parentDelegate);对参数进行初始化 123456public void initDefaults(Element root, @Nullable BeanDefinitionParserDelegate parent) &#123; // 对DocumentDefaultsDefinition属性进行初始化 populateDefaults(this.defaults, (parent != null ? parent.defaults : null), root); // 发出响应事件告知监听器DocumentDefaultsDefinition初始化完毕 this.readerContext.fireDefaultsRegistered(this.defaults);&#125; 在参数初始化过程中主要完成了两件事，一是通过populateDefaults方法对属性defaults:DocumentDefaultsDefinition进行初始化(涉及属性有default lazy-init, autowire, dependency check settings, init-method, destroy-method and merge settings)，二是发出响应事件告知监听器DocumentDefaultsDefinition初始化完毕，可以自行扩展该方法进行修改DocumentDefaultsDefinition的参数值(Spring只提供了空实现 若要使用该功能需自行扩展) (扩展EMO)背景是工程单元测试希望和生产环境共用一份Spring配置文件，生产环境应用为了客户体验使用非LazyInit模式，但是单元测试下为了提高响应时间希望LazyInit 新建自定义事件监听器1234567891011121314151617181920212223242526272829package org.springframework.roberto._03_lazy_init;import org.springframework.beans.factory.parsing.*;import org.springframework.beans.factory.xml.DocumentDefaultsDefinition;public class CustomerEventListener implements ReaderEventListener &#123; @Override public void defaultsRegistered(DefaultsDefinition defaultsDefinition) &#123; if (defaultsDefinition instanceof DocumentDefaultsDefinition) &#123; DocumentDefaultsDefinition defaults = (DocumentDefaultsDefinition) defaultsDefinition; defaults.setLazyInit(\"true\"); &#125; &#125; @Override public void componentRegistered(ComponentDefinition componentDefinition) &#123; &#125; @Override public void aliasRegistered(AliasDefinition aliasDefinition) &#123; &#125; @Override public void importProcessed(ImportDefinition importDefinition) &#123; &#125;&#125; 新建LazyInitClasspathXmlApplicationContext类继承ClassPathXmlApplicationContext 并重写initBeanDefinitionReader方法1234567891011121314151617package org.springframework.roberto._03_lazy_init;import org.springframework.beans.BeansException;import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;import org.springframework.context.support.ClassPathXmlApplicationContext;public class LazyInitClasspathXmlApplicationContext extends ClassPathXmlApplicationContext &#123; public LazyInitClasspathXmlApplicationContext(String... configLocations) throws BeansException &#123; super(configLocations); &#125; @Override protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) &#123; super.initBeanDefinitionReader(reader); reader.setEventListener(new CustomerEventListener()); &#125;&#125; 新建实体类TestLazyInitBean123456789101112package org.springframework.roberto._03_lazy_init;public class TestLazyInitBean &#123; public void init() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"TestBean Init\"); &#125;&#125; 修改配置文件如下1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"testLazyInitBean\" class=\"org.springframework.roberto._03_lazy_init.TestLazyInitBean\" init-method=\"init\"/&gt;&lt;/beans&gt; 测试方法如下123456789101112131415161718package org.springframework.roberto;import org.junit.Test;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.roberto._03_lazy_init.LazyInitClasspathXmlApplicationContext;public class _03_LazyInitTest &#123; @Test public void testLayzyInit() &#123; long currentTime = System.currentTimeMillis(); new ClassPathXmlApplicationContext(\"03.lazy_init.xml\"); System.out.println(\"No LazyInit Cost Time:\" + (System.currentTimeMillis() - currentTime)); currentTime = System.currentTimeMillis(); new LazyInitClasspathXmlApplicationContext(\"03.lazy_init.xml\"); System.out.println(\"LazyInit Cost Time:\" + (System.currentTimeMillis() - currentTime)); &#125;&#125; 测试结果123TestBean InitNo LazyInit Cost Time:6203LazyInit Cost Time:37 测试结果表明这里确实改变了Spring的懒加载设置，其实此处原理就是修改了ReaderContext的ReaderEventListener的实现 这里使用ClassPathXmlApplicationContext方式测试是因为BeanFactory采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean)才对该Bean进行加载实例化，我们就不能发现一些存在的Spring配置问题，而ApplicationContext则相反它是在容器启动时一次性创建了所有的Bean，这样在容器启动时，我们就可以发现Spring中存在的错误。相对于BeanFactory而言，ApplicationContext唯一的不足就是占用内存空间，当应用程序配置Bean较多时程序启动慢 对profiles属性使用解析，修改配置文件如下: (最外层beans的profile属性为可能出现的环境 内层的profile指向具体环境)12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" profile=\"dev,test\"&gt; &lt;beans profile=\"dev\"&gt; &lt;bean id=\"testProfileBean\" class=\"org.springframework.roberto._04_profile.TestProfileBean\"&gt;&lt;/bean&gt; &lt;/beans&gt; &lt;beans profile=\"test\"&gt; &lt;/beans&gt;&lt;/beans&gt; 新建测试类123456789101112131415161718package org.springframework.roberto;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;import org.springframework.roberto._04_profile.TestProfileBean;@SuppressWarnings(\"all\")public class _04_ProfileTest &#123; @Test public void testProfile() &#123; System.setProperty(\"spring.profiles.active\",\"dev\"); BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(\"04.profile.xml\")); TestProfileBean testProfileBeant = (TestProfileBean) beanFactory.getBean(\"testProfileBean\"); System.out.println(testProfileBeant); &#125;&#125; 测试通过说明dev配置是生效的，若将spring.profiles.active设置成test测试不通过。在集成到Web环境中时，可以在web.xml中加入以下代码1234&lt;context-param&gt; &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; 有了这个特性我们就可以同时在配置文件中部署两套配置来适用于生产环境和开发环境，这样可以方便的进行切换开发、部署环境，最常用的就是更换不同的数据库了(这种方式其实并不直观 现在项目大多数是Maven项目 Maven的profiles对多环境支持更强大)","categories":[{"name":"Spring源码深度解析","slug":"Spring源码深度解析","permalink":"http://huangth.com/categories/Spring源码深度解析/"}],"tags":[{"name":"Spring源码深度解析","slug":"Spring源码深度解析","permalink":"http://huangth.com/tags/Spring源码深度解析/"},{"name":"Spring容器实现","slug":"Spring容器实现","permalink":"http://huangth.com/tags/Spring容器实现/"},{"name":"Spring配置加载","slug":"Spring配置加载","permalink":"http://huangth.com/tags/Spring配置加载/"},{"name":"Spring IOC源码解析","slug":"Spring-IOC源码解析","permalink":"http://huangth.com/tags/Spring-IOC源码解析/"}]},{"title":"01.Spring源码深度解析之IDEA源码阅读环境搭建","slug":"01.Spring源码深度解析之IDEA源码阅读环境搭建","date":"2017-12-22T04:00:00.000Z","updated":"2018-03-08T14:45:24.237Z","comments":true,"path":"2017/12/22/01.Spring源码深度解析之IDEA源码阅读环境搭建/","link":"","permalink":"http://huangth.com/2017/12/22/01.Spring源码深度解析之IDEA源码阅读环境搭建/","excerpt":"前言相信大部分人在面试过程中都会被问到是否阅读过Spring源码 Spring底层如何实现 Spring使用了哪些设计模式等问题，通常遇到这种问题我是直接选择死亡。因为开始我觉的花时间去研究一门框架不如多学习几个开源框架性价比来的高，可能花几天时间你能用一个新框架撸码，但是花几天时间研究Spring真的研究不出什么道来，不过渐渐的我发现程序员如果想自身的核心竞争力除了增加知识的广度外更重要的是能在某个方面有个深度。我想百分90的程序员都有在用Spring框架但是可能只有百分10不到的程序员研究过Spring框架，它是个十分成熟的开源框架，有着各路武林高手多年积淀下来的精华，为了应付面试也好提高自身编程思想也好我认为研究Spring源码还是很有必要的，因为阅读源码等同于你获得了一次和大师学习的机会，站在巨人的肩膀上才会看的更远","text":"前言相信大部分人在面试过程中都会被问到是否阅读过Spring源码 Spring底层如何实现 Spring使用了哪些设计模式等问题，通常遇到这种问题我是直接选择死亡。因为开始我觉的花时间去研究一门框架不如多学习几个开源框架性价比来的高，可能花几天时间你能用一个新框架撸码，但是花几天时间研究Spring真的研究不出什么道来，不过渐渐的我发现程序员如果想自身的核心竞争力除了增加知识的广度外更重要的是能在某个方面有个深度。我想百分90的程序员都有在用Spring框架但是可能只有百分10不到的程序员研究过Spring框架，它是个十分成熟的开源框架，有着各路武林高手多年积淀下来的精华，为了应付面试也好提高自身编程思想也好我认为研究Spring源码还是很有必要的，因为阅读源码等同于你获得了一次和大师学习的机会，站在巨人的肩膀上才会看的更远阅读Spring源码是一万次的心跳呼吸也是一万次的低头叹息，感觉还是很吃力特对对我这种没有源码阅读经验的菜鸡而言，但是每次坚持下来都会有意外的收获，读书百遍其义自见吧。在源码阅读过程中主要参考了郝佳的Spring源码深度解析，从代码角度进行剖析由浅入深，然后看源码过程中顺带看了些设计模式的内容，主要参考了程杰的大话设计模式，再然后还参考了数不清的技术博客，我们不生产水我们只是大自然的搬运工，我只是对这些大佬的见解进行汇总，如有侵权请及时联系。然后顺带安利个比较实用的UML图软件Visual Paradigm，页面简洁功能强大，谁用谁知道 然后再分享个看源码的经验吧，因为Spring源码层级结构较深，很容易就找不到自己想要定位的类，巧用IDEA的书签功能可以很好的解决该问题，IDEA的类图谱功能可以帮助我们理清类之间的依赖关系，Find Usages可以帮我们理清类之间的调用关系。再然后来个免责声明吧，本人不是高级软件开发工程师也不是什么架构师，只是一个刚刚学Java的菜鸡，菜的抠脚的那种，但是该博客是用心码出来的，所以如果你在看该博客有任何被坑的地方还请您多多担待，最后希望各位大佬不吝赐教不胜感激… 博客源码地址:https://github.com/RobertoHuang/spring-framework.git Spring整体架构网上找了一张Spring的架构框图，可以看出模块构成关系，了解即可不必过于纠结 Spring源码阅读环境构建下载Spring源码现在大型开源项目都由Github托管了，Spring也不例外。所以我们可以直接在Github上搜索spring-framework找到Spring项目下载ZIP包，或者直接通过以下命令检出Spring源码，如果对GIT还不了解的同学可以百度搜索廖雪峰GIT教程，相信很快就能上手1git clone https://github.com/spring-projects/spring-framework.git JDK版本最新版的Spring源码编译要求jdk1.8+版本，至于JDK环境变量配置在此就不赘述了 Gradle环境1234配置:1.创建系统环境变量:GRADLE_HOME 指向Gradle安装目录2.配置path:新增%GRADLE_HOME%\\bin;3.配置完成后打开CMD输入gradle -v看是否成功 IntelliJ IDEA版本阅读Spring源码对IntelliJ IDEA版本其实是没有要求的，但是不得不提一下的是如果你的IntelliJ IDEA版本是2017.1及以下的版本的话，那Gradle的版本用3.5的就可以了，用新版的Gradle可能会出问题 Spring源码编译并导入IDEA在下载下来的Spring源码的根目录下有个import-into-idea.md的文件，里面介绍了如何使用将Spring源码导入IDEA，并且讲述了在此过程中应该注意的一些问题，大致步骤如下 1.注释根目录settings.gradle文件下的jcenter()以及spring-aspects模块12345678pluginManagement &#123; repositories &#123; // jcenter() gradlePluginPortal() &#125;&#125;// include \"spring-aspects\" 2.注释spring-oxm下spring-oxm.gradle文件的jibx模块12345// jibx(verbose: true, load: true, binding: bindingXml) &#123; // classpathset(dir: sourceSets.test.java.outputDir) &#123; // include(name: \"**/jibx/**/*\") // &#125;// &#125; 3.预编译spring-oxm模块，使用如下命令(此过程中可能由于网络问题失败 多重试几次)1gradle :spring-oxm:compileTestJava 4.导入项目到IDEA中，选择使用Gradle构建并配置Gradle环境 5.等待构建完成即可 至此Spring源码阅读环境已搭建完毕","categories":[{"name":"Spring源码深度解析","slug":"Spring源码深度解析","permalink":"http://huangth.com/categories/Spring源码深度解析/"}],"tags":[{"name":"Spring源码深度解析","slug":"Spring源码深度解析","permalink":"http://huangth.com/tags/Spring源码深度解析/"},{"name":"Spring源码环境搭建","slug":"Spring源码环境搭建","permalink":"http://huangth.com/tags/Spring源码环境搭建/"}]},{"title":"前辈分享的经典语句","slug":"前辈分享的经典语句","date":"2017-12-12T04:12:12.000Z","updated":"2018-03-08T14:45:24.240Z","comments":true,"path":"2017/12/12/前辈分享的经典语句/","link":"","permalink":"http://huangth.com/2017/12/12/前辈分享的经典语句/","excerpt":"一个人的心态很重要心量小的人 芝麻大小的事情也能在心里翻江倒海心量大的人 即使在危机面前也能镇定自若同样一件事情 掀起的波澜大小缺因人而异有一句话很好 用于技术人员我觉得尤其合适想要成为一棵大树 就不要去和草争","text":"一个人的心态很重要心量小的人 芝麻大小的事情也能在心里翻江倒海心量大的人 即使在危机面前也能镇定自若同样一件事情 掀起的波澜大小缺因人而异有一句话很好 用于技术人员我觉得尤其合适想要成为一棵大树 就不要去和草争 一个人的成就 不可以用金钱来衡量而是一生中 你善待过多少人 有多少人怀恋你成功并非单指事业无论是爱好或职业上的成功都只是成就成功应该是多元化的如人的一生包含了很多追求一样 而非单一指向然后 无论你多有成就真正的成功 就是陪伴家人所有的情感都是需要陪伴的这些陪伴成为一个个美好的记忆这些都是整个家庭最宝贵 最重要的财富这些远远超过物质的重要性 在中国因为价值观相对比较单一社会显得浮躁 很物质所以大多以物质的追求为主越多越好 内心也想过美好的生活但当你的心完全趋向于金钱的时候很多美好的东西就自动屏蔽了不会出现在生活中别让忙碌空白了回忆 此外作为一名技术人员 我觉得职业生涯中可能很多次需要面对工作的变换 角色的变化有很多知识需要学习所以 我们应该把“归零”当成一种生活的新常态","categories":[{"name":"个人博客","slug":"个人博客","permalink":"http://huangth.com/categories/个人博客/"}],"tags":[{"name":"心灵鸡汤","slug":"心灵鸡汤","permalink":"http://huangth.com/tags/心灵鸡汤/"}]}]}